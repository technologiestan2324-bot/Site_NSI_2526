<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrig√© Version A - Mini-Projet POO-Processus</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .version-badge {
            background: #667eea;
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
            font-weight: bold;
        }

        h2 {
            color: #764ba2;
            margin-top: 35px;
            margin-bottom: 15px;
            font-size: 1.8em;
            border-left: 5px solid #667eea;
            padding-left: 15px;
        }

        h3 {
            color: #667eea;
            margin-top: 25px;
            margin-bottom: 12px;
            font-size: 1.3em;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            border: 2px solid #667eea;
        }

        code {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .reponse {
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .reponse strong {
            color: #667eea;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .gantt {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        .print-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .print-btn:hover {
            transform: translateY(-3px);
        }

        ul {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        @media print {
            body {
                background: white;
                padding: 0;
            }

            .container {
                box-shadow: none;
            }

            .print-btn {
                display: none;
            }
        }
    </style>
</head>
<body>
    <button class="print-btn" onclick="window.print()">üñ®Ô∏è Imprimer</button>

    <div class="container">
        <h1>üìö Corrig√© Mini-Projet POO-Processus</h1>
        <div style="text-align: center;">
            <span class="version-badge">VERSION A</span>
        </div>

        <h2>Exercice 1 : La classe Processus</h2>

        <h3>Question 1.1 : Code de la classe</h3>
<pre><code># Fichier: processus.py

class Processus:
    """Classe repr√©sentant un processus avec ses caract√©ristiques"""
    
    def __init__(self, pid, arrivee, duree):
        """
        Initialise un processus
        pid: identifiant unique
        arrivee: temps d'arriv√©e
        duree: dur√©e d'ex√©cution totale
        """
        self.pid = pid
        self.arrivee = arrivee
        self.duree = duree
        self.duree_restante = duree  # Pour algorithmes pr√©emptifs
        self.debut = None  # Temps de d√©but d'ex√©cution
        self.fin = None    # Temps de fin d'ex√©cution
        
    def temps_traitement(self):
        """Calcule le temps de traitement (turnaround time)"""
        if self.fin is not None:
            return self.fin - self.arrivee
        return None
    
    def temps_attente(self):
        """Calcule le temps d'attente"""
        if self.fin is not None:
            return self.temps_traitement() - self.duree
        return None
    
    def __repr__(self):
        """Repr√©sentation textuelle du processus"""
        return f"P{self.pid}(arr={self.arrivee}, dur={self.duree})"
</code></pre>

        <h3>Question 1.3 : R√©ponse</h3>
        <div class="reponse">
            <strong>R√©ponse :</strong> <code>duree</code> repr√©sente la dur√©e totale n√©cessaire pour ex√©cuter compl√®tement le processus (elle ne change jamais). <code>duree_restante</code> repr√©sente le temps d'ex√©cution qu'il reste au processus, elle diminue au fur et √† mesure de l'ex√©cution. Cette distinction est cruciale pour les algorithmes pr√©emptifs (Round Robin, SRTF) o√π un processus peut √™tre interrompu puis repris plus tard. Pour les algorithmes non pr√©emptifs (FIFO, SJF), les deux valeurs restent identiques jusqu'√† la fin de l'ex√©cution.
        </div>

        <h2>Exercice 2 : Round Robin</h2>

        <h3>Question 2.1 : Code Round Robin</h3>
<pre><code># Fichier: ordonnancement.py

from processus import Processus

def round_robin(processus_liste, quantum):
    """
    Algorithme Round Robin avec quantum variable
    Chaque processus re√ßoit un quantum de temps
    """
    # Copie des processus pour ne pas modifier l'original
    processus = []
    for p in processus_liste:
        nouveau = Processus(p.pid, p.arrivee, p.duree)
        processus.append(nouveau)
    
    temps_actuel = 0
    file_attente = []  # File FIFO des processus pr√™ts
    termines = []
    i = 0  # Index pour parcourir les processus
    
    # Trier par arriv√©e
    processus = sorted(processus, key=lambda p: p.arrivee)
    
    while len(termines) < len(processus):
        # Ajouter les processus qui viennent d'arriver
        while i < len(processus) and processus[i].arrivee <= temps_actuel:
            file_attente.append(processus[i])
            i += 1
        
        # Si aucun processus n'est pr√™t
        if not file_attente:
            temps_actuel = processus[i].arrivee
            continue
        
        # Prendre le premier de la file
        p = file_attente.pop(0)
        
        # D√©finir le d√©but si premi√®re ex√©cution
        if p.debut is None:
            p.debut = temps_actuel
        
        # Ex√©cuter pendant min(quantum, dur√©e restante)
        temps_exec = min(quantum, p.duree_restante)
        temps_actuel += temps_exec
        p.duree_restante -= temps_exec
        
        # Ajouter les nouveaux arrivants pendant l'ex√©cution
        while i < len(processus) and processus[i].arrivee <= temps_actuel:
            file_attente.append(processus[i])
            i += 1
        
        # V√©rifier si termin√©
        if p.duree_restante == 0:
            p.fin = temps_actuel
            termines.append(p)
        else:
            # Remettre en fin de file
            file_attente.append(p)
    
    return sorted(termines, key=lambda p: p.pid)
</code></pre>

        <h3>Question 2.2 : R√©sultats avec quantum=3</h3>
<pre><code># Test
processus = [
    Processus(1, 0, 9),
    Processus(2, 2, 5),
    Processus(3, 4, 3),
    Processus(4, 6, 7)
]

resultat = round_robin(processus, quantum=3)
</code></pre>

        <table>
            <tr>
                <th>PID</th>
                <th>Arriv√©e</th>
                <th>Dur√©e</th>
                <th>D√©but</th>
                <th>Fin</th>
                <th>Attente</th>
                <th>Traitement</th>
            </tr>
            <tr><td>1</td><td>0</td><td>9</td><td>0</td><td>21</td><td>12</td><td>21</td></tr>
            <tr><td>2</td><td>2</td><td>5</td><td>3</td><td>15</td><td>10</td><td>13</td></tr>
            <tr><td>3</td><td>4</td><td>3</td><td>6</td><td>9</td><td>2</td><td>5</td></tr>
            <tr><td>4</td><td>6</td><td>7</td><td>9</td><td>24</td><td>11</td><td>18</td></tr>
        </table>

        <p><strong>Temps d'attente moyen :</strong> (12 + 10 + 2 + 11) / 4 = 8.75</p>

        <h3>Question 2.4 : Diagramme de Gantt (quantum=3)</h3>
        <div class="gantt">
<pre>
Temps:  0   3   6   9   12  15  18  21  24
       |---|---|---|---|---|---|---|---|
P1     |###|   |   |###|   |   |###|   |
P2     |   |###|   |   |##|   |   |   |
P3     |   |   |###|   |   |   |   |   |
P4     |   |   |   |###|   |###|   |###|

L√©gende : ### = Ex√©cution

Ordre d'ex√©cution : P1(3) ‚Üí P2(3) ‚Üí P3(3) ‚Üí P1(3) ‚Üí P4(3) ‚Üí P2(2) ‚Üí P1(3) ‚Üí P4(3) ‚Üí P4(1)
</pre>
        </div>

        <h3>Question 2.3 : Impact du quantum</h3>
        <div class="reponse">
            <strong>Quantum = 1 :</strong> Temps d'attente moyen ‚âà 9.5. Tr√®s nombreux changements de contexte (overhead important), mais tr√®s √©quitable.<br><br>
            <strong>Quantum = 5 :</strong> Temps d'attente moyen ‚âà 8.25. Moins de changements de contexte, proche d'un algorithme non pr√©emptif pour les processus courts.<br><br>
            <strong>Conclusion :</strong> Un quantum trop petit augmente l'overhead, un quantum trop grand r√©duit l'√©quit√©. Le quantum optimal d√©pend du contexte (quantum=2 ou 3 souvent recommand√©).
        </div>

        <h2>Exercice 3 : SRTF</h2>

        <h3>Question 3.1 : Code SRTF</h3>
<pre><code>def srtf(processus_liste):
    """
    SRTF (Shortest Remaining Time First) - Pr√©emptif
    S√©lectionne toujours le processus avec le temps restant le plus court
    """
    processus = []
    for p in processus_liste:
        nouveau = Processus(p.pid, p.arrivee, p.duree)
        processus.append(nouveau)
    
    temps_actuel = 0
    termines = []
    non_termines = sorted(processus, key=lambda p: p.arrivee)
    
    while non_termines:
        # Processus disponibles
        disponibles = [p for p in non_termines if p.arrivee <= temps_actuel]
        
        if not disponibles:
            temps_actuel = min(p.arrivee for p in non_termines)
            continue
        
        # Choisir celui avec le temps restant le plus court
        p = min(disponibles, key=lambda x: x.duree_restante)
        
        if p.debut is None:
            p.debut = temps_actuel
        
        # Trouver le prochain √©v√©nement (arriv√©e)
        prochain_arrivee = float('inf')
        for proc in non_termines:
            if proc.arrivee > temps_actuel:
                prochain_arrivee = min(prochain_arrivee, proc.arrivee)
        
        # Ex√©cuter jusqu'au prochain √©v√©nement ou fin
        temps_exec = min(p.duree_restante, prochain_arrivee - temps_actuel)
        
        temps_actuel += temps_exec
        p.duree_restante -= temps_exec
        
        # V√©rifier si termin√©
        if p.duree_restante == 0:
            p.fin = temps_actuel
            termines.append(p)
            non_termines.remove(p)
    
    return sorted(termines, key=lambda p: p.pid)
</code></pre>

        <h3>Question 3.2 : R√©sultats SRTF</h3>
<pre><code># Test
processus = [
    Processus(1, 0, 8),
    Processus(2, 1, 2),
    Processus(3, 3, 4),
    Processus(4, 5, 1),
    Processus(5, 6, 3)
]
</code></pre>

        <table>
            <tr>
                <th>PID</th>
                <th>Arriv√©e</th>
                <th>Dur√©e</th>
                <th>D√©but</th>
                <th>Fin</th>
                <th>Attente</th>
                <th>Traitement</th>
            </tr>
            <tr><td>1</td><td>0</td><td>8</td><td>0</td><td>18</td><td>10</td><td>18</td></tr>
            <tr><td>2</td><td>1</td><td>2</td><td>1</td><td>3</td><td>0</td><td>2</td></tr>
            <tr><td>3</td><td>3</td><td>4</td><td>6</td><td>10</td><td>3</td><td>7</td></tr>
            <tr><td>4</td><td>5</td><td>1</td><td>5</td><td>6</td><td>0</td><td>1</td></tr>
            <tr><td>5</td><td>6</td><td>3</td><td>10</td><td>13</td><td>4</td><td>7</td></tr>
        </table>

        <p><strong>Temps d'attente moyen :</strong> (10 + 0 + 3 + 0 + 4) / 5 = 3.4</p>

        <h3>Question 3.3 : Processus le plus interrompu</h3>
        <div class="reponse">
            <strong>R√©ponse :</strong> P1 est le plus interrompu car il a la plus longue dur√©e (8). Il commence √† t=0, mais est pr√©empt√© par P2 (plus court) √† t=1, puis par P4 (plus court) √† t=5. Il ne reprend qu'apr√®s que tous les processus plus courts soient termin√©s. C'est une caract√©ristique de SRTF : les longs processus peuvent subir de nombreuses pr√©emptions si des processus courts arrivent.
        </div>

        <h2>Exercice 4 : FIFO</h2>

        <h3>Question 4.1 : Code FIFO</h3>
<pre><code>def fifo(processus_liste):
    """
    FIFO (First In First Out) - Premier arriv√©, premier servi
    Non pr√©emptif, ordre chronologique
    """
    processus = sorted(processus_liste, key=lambda p: p.arrivee)
    temps_actuel = 0
    
    for p in processus:
        # Si le CPU est libre avant l'arriv√©e
        if temps_actuel < p.arrivee:
            temps_actuel = p.arrivee
        
        p.debut = temps_actuel
        temps_actuel += p.duree
        p.fin = temps_actuel
    
    return processus
</code></pre>

        <h3>Question 4.3 : Principal probl√®me de FIFO</h3>
        <div class="reponse">
            <strong>R√©ponse :</strong> Le principal probl√®me est l'<strong>effet de convoi</strong> (convoy effect). Si un processus long (comme P1 avec dur√©e 12) arrive en premier, tous les autres processus courts doivent attendre qu'il se termine, m√™me s'ils pourraient s'ex√©cuter rapidement. Cela augmente consid√©rablement le temps d'attente moyen. Dans l'exemple, P2, P3 et P4 attendent tous pendant l'ex√©cution compl√®te de P1.
        </div>

        <h2>Exercice 5 : SJF</h2>

        <h3>Question 5.1 : Code SJF</h3>
<pre><code>def sjf(processus_liste):
    """
    SJF (Shortest Job First) - Non pr√©emptif
    S√©lectionne le processus le plus court parmi ceux disponibles
    """
    processus = [p for p in processus_liste]
    temps_actuel = 0
    termines = []
    
    while processus:
        # Processus d√©j√† arriv√©s
        disponibles = [p for p in processus if p.arrivee <= temps_actuel]
        
        if not disponibles:
            # Avancer au prochain arrivant
            temps_actuel = min(p.arrivee for p in processus)
            continue
        
        # Choisir le plus court
        p = min(disponibles, key=lambda x: x.duree)
        
        p.debut = temps_actuel
        temps_actuel += p.duree
        p.fin = temps_actuel
        
        termines.append(p)
        processus.remove(p)
    
    return termines
</code></pre>

        <h3>Question 5.3 : Cas optimal pour SJF</h3>
        <div class="reponse">
            <strong>R√©ponse :</strong> SJF donne des r√©sultats optimaux (temps d'attente moyen minimal) lorsque :
            <ul>
                <li>Les dur√©es d'ex√©cution sont connues √† l'avance (ce qui est rarement le cas en pratique)</li>
                <li>Il y a une grande variance dans les dur√©es (processus tr√®s courts et tr√®s longs)</li>
                <li>Les processus arrivent tous au m√™me moment ou dans un court intervalle</li>
            </ul>
            SJF minimise math√©matiquement le temps d'attente moyen, mais peut causer la famine des processus longs.
        </div>

        <h2>Exercice 6 : Comparaison finale</h2>

        <h3>Question 6.2 : R√©sultats sur processus_final</h3>
<pre><code>processus_final = [
    Processus(1, 0, 10),
    Processus(2, 1, 3),
    Processus(3, 3, 7),
    Processus(4, 5, 5),
    Processus(5, 7, 2)
]
</code></pre>

        <table>
            <tr>
                <th>Algorithme</th>
                <th>Temps attente moyen</th>
                <th>Temps traitement moyen</th>
                <th>Classement</th>
            </tr>
            <tr>
                <td>Round Robin (q=3)</td>
                <td>9.6</td>
                <td>15.0</td>
                <td>3√®me</td>
            </tr>
            <tr>
                <td>SRTF</td>
                <td>3.8</td>
                <td>9.2</td>
                <td>1er (meilleur)</td>
            </tr>
            <tr>
                <td>FIFO</td>
                <td>11.2</td>
                <td>16.6</td>
                <td>4√®me (pire)</td>
            </tr>
            <tr>
                <td>SJF</td>
                <td>5.4</td>
                <td>10.8</td>
                <td>2√®me</td>
            </tr>
        </table>

        <h3>Question 6.4 : Recommandation pour syst√®me interactif</h3>
        <div class="reponse">
            <strong>R√©ponse :</strong> Pour un syst√®me interactif (ordinateur personnel), je recommande <strong>Round Robin</strong> avec un quantum appropri√© (2-4 ms). Raisons :
            <ul>
                <li><strong>√âquit√© :</strong> Tous les processus re√ßoivent r√©guli√®rement du temps CPU, aucun n'est ignor√©</li>
                <li><strong>R√©activit√© :</strong> Les applications interactives (navigateur, √©diteur) ne bloquent pas longtemps</li>
                <li><strong>Pas de famine :</strong> Contrairement √† SJF/SRTF, les processus longs ne sont pas d√©favoris√©s</li>
                <li><strong>Pr√©visibilit√© :</strong> Temps de r√©ponse maximum calculable</li>
            </ul>
            Bien que SRTF ait le meilleur temps d'attente moyen, il peut causer la famine et n√©cessite de conna√Ætre les dur√©es √† l'avance (impossible en pratique). Round Robin est le meilleur compromis entre performance et √©quit√© pour un usage interactif.
        </div>

        <h2>üìù Fonction d'affichage compl√®te</h2>

<pre><code>def afficher_resultats(processus, titre="R√©sultats"):
    """Affiche les r√©sultats de l'ordonnancement de mani√®re format√©e"""
    print("\n" + "="*80)
    print(f"{titre:^80}")
    print("="*80)
    print(f"{'PID':<5} {'Arr':<6} {'Dur':<6} {'D√©but':<8} {'Fin':<8} {'Attente':<10} {'Traitement':<10}")
    print("="*80)
    
    total_attente = 0
    total_traitement = 0
    
    for p in sorted(processus, key=lambda x: x.pid):
        attente = p.temps_attente()
        traitement = p.temps_traitement()
        total_attente += attente
        total_traitement += traitement
        
        print(f"{p.pid:<5} {p.arrivee:<6} {p.duree:<6} {p.debut:<8} {p.fin:<8} {attente:<10} {traitement:<10}")
    
    print("="*80)
    print(f"Temps d'attente moyen : {total_attente / len(processus):.2f}")
    print(f"Temps de traitement moyen : {total_traitement / len(processus):.2f}\n")
</code></pre>

        <h2>üìä Points cl√©s √† retenir</h2>

        <div class="reponse">
            <strong>Concepts importants :</strong>
            <ul>
                <li><strong>Pr√©emptif vs non pr√©emptif :</strong> Un algorithme pr√©emptif peut interrompre un processus en cours</li>
                <li><strong>Temps d'attente :</strong> Temps total - dur√©e d'ex√©cution</li>
                <li><strong>Temps de traitement :</strong> Temps entre arriv√©e et fin</li>
                <li><strong>FIFO :</strong> Simple mais effet de convoi</li>
                <li><strong>SJF :</strong> Optimal pour temps d'attente mais risque de famine</li>
                <li><strong>Round Robin :</strong> √âquitable, bon pour syst√®mes interactifs</li>
                <li><strong>SRTF :</strong> Version pr√©emptive de SJF, encore plus optimal mais plus complexe</li>
            </ul>
        </div>
    </div>
</body>
</html>
