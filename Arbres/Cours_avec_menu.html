<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Les Arbres Binaires - NSI Terminale</title>
    
 <link rel="stylesheet" href="../style.css">
</head>
<body>
<!-- Emplacement du menu -->
    <div id="menu-container"></div>

    <script>
document.addEventListener("DOMContentLoaded", function () {
    fetch("../menu.html")
        .then(response => {
            if (!response.ok) {
                throw new Error("Menu introuvable");
            }
            return response.text();
        })
        .then(data => {
            document.getElementById("menu-container").innerHTML = data;
        })
        .catch(error => console.log("Erreur :", error));
});
</script
    <div class="navigation">
        <strong>Navigation :</strong>
        <a href="https://technologiestan2324-bot.github.io/Site_NSI_2526/">‚Üê Retour au siti de NSI Betina</a>
       
    </div>
    <h1>üå≥ Les Arbres Binaires</h1>
    <p><strong>Programme NSI Terminale</strong> - Conforme au Bulletin Officiel</p>

    <div class="objectifs">
        <h3>üìö Objectifs du chapitre (B.O.)</h3>
        <ul>
            <li>Identifier des situations n√©cessitant une structure de donn√©es arborescente</li>
            <li>√âvaluer la hauteur et la taille d'un arbre</li>
            <li>Parcourir un arbre de diff√©rentes fa√ßons (parcours pr√©fixe, infixe, suffixe, en largeur)</li>
            <li>Distinguer les arbres binaires de recherche (ABR)</li>
            <li>Impl√©menter les op√©rations de base sur les arbres binaires</li>
        </ul>
    </div>

    <h2>I. Introduction aux arbres</h2>

    <h3>1.1 Motivation</h3>
    <p>Les arbres sont des structures de donn√©es non lin√©aires, hi√©rarchiques, utilis√©es pour repr√©senter des relations de parent√© ou d'ordre. Ils sont omnipr√©sents en informatique :</p>
    <ul>
        <li>Syst√®mes de fichiers (dossiers et sous-dossiers)</li>
        <li>DOM (Document Object Model) en HTML</li>
        <li>Arbres de d√©cision en intelligence artificielle</li>
        <li>Structures de donn√©es pour optimiser les recherches (ABR, arbres AVL)</li>
    </ul>

    <div class="definition">
        <h3>üìñ D√©finition : Arbre</h3>
        <p>Un <strong>arbre</strong> est une structure de donn√©es constitu√©e de <strong>n≈ìuds</strong> reli√©s par des <strong>ar√™tes</strong>, avec les propri√©t√©s suivantes :</p>
        <ul>
            <li>Il existe un n≈ìud particulier appel√© <strong>racine</strong></li>
            <li>Chaque n≈ìud (sauf la racine) poss√®de exactement un <strong>parent</strong></li>
            <li>Il n'y a pas de cycle (pas de chemin qui revient au point de d√©part)</li>
            <li>Tous les n≈ìuds sont accessibles depuis la racine</li>
        </ul>
    </div>

    <h3>1.2 Vocabulaire des arbres</h3>
    <table>
        <tr>
            <th>Terme</th>
            <th>D√©finition</th>
        </tr>
        <tr>
            <td><strong>Racine</strong></td>
            <td>N≈ìud de d√©part de l'arbre, sans parent</td>
        </tr>
        <tr>
            <td><strong>Feuille</strong></td>
            <td>N≈ìud sans enfant</td>
        </tr>
        <tr>
            <td><strong>N≈ìud interne</strong></td>
            <td>N≈ìud qui n'est ni racine ni feuille (poss√®de au moins un enfant)</td>
        </tr>
        <tr>
            <td><strong>Hauteur</strong></td>
            <td>Longueur du plus long chemin de la racine √† une feuille</td>
        </tr>
        <tr>
            <td><strong>Taille</strong></td>
            <td>Nombre total de n≈ìuds dans l'arbre</td>
        </tr>
        <tr>
            <td><strong>Profondeur (niveau)</strong></td>
            <td>Distance d'un n≈ìud √† la racine</td>
        </tr>
        <tr>
            <td><strong>Sous-arbre</strong></td>
            <td>Arbre form√© par un n≈ìud et tous ses descendants</td>
        </tr>
    </table>

    <h2>II. Les arbres binaires</h2>

    <div class="definition">
        <h3>üìñ D√©finition : Arbre binaire</h3>
        <p>Un <strong>arbre binaire</strong> est un arbre dans lequel chaque n≈ìud poss√®de <strong>au plus deux enfants</strong>, appel√©s <strong>fils gauche</strong> et <strong>fils droit</strong>.</p>
    </div>

    <div class="exemple">
        <h3>üí° Exemple d'arbre binaire</h3>
        <pre><code>        15
       /  \
      10   20
     / \   / \
    5  12 18 25
   /
  3
</code></pre>
        <p>Dans cet arbre :</p>
        <ul>
            <li>Racine : 15</li>
            <li>Hauteur : 3 (chemin 15 ‚Üí 10 ‚Üí 5 ‚Üí 3)</li>
            <li>Taille : 7 n≈ìuds</li>
            <li>Feuilles : 3, 12, 18, 25</li>
        </ul>
    </div>

    <h3>2.1 Impl√©mentation en Python</h3>
    <p>On utilise g√©n√©ralement une classe pour repr√©senter un n≈ìud d'arbre binaire :</p>

    <pre><code class="python">class Noeud:
    def __init__(self, valeur, gauche=None, droit=None):
        self.valeur = valeur
        self.gauche = gauche
        self.droit = droit
    
    def est_feuille(self):
        """V√©rifie si le n≈ìud est une feuille"""
        return self.gauche is None and self.droit is None

# Construction de l'arbre exemple
arbre = Noeud(15,
    Noeud(10,
        Noeud(5, Noeud(3), None),
        Noeud(12)),
    Noeud(20,
        Noeud(18),
        Noeud(25))
)
</code></pre>

    <h3>2.2 Calcul de la taille d'un arbre</h3>
    <p>La taille se calcule r√©cursivement :</p>
    <pre><code class="python">def taille(arbre):
    """Retourne le nombre de n≈ìuds dans l'arbre"""
    if arbre is None:
        return 0
    return 1 + taille(arbre.gauche) + taille(arbre.droit)

# Exemple d'utilisation
print(taille(arbre))  # Affiche : 7
</code></pre>

    <h3>2.3 Calcul de la hauteur d'un arbre</h3>
    <p>La hauteur se calcule √©galement de mani√®re r√©cursive :</p>
    <pre><code class="python">def hauteur(arbre):
    """Retourne la hauteur de l'arbre"""
    if arbre is None:
        return -1  # Convention : arbre vide a hauteur -1
    return 1 + max(hauteur(arbre.gauche), hauteur(arbre.droit))

# Exemple d'utilisation
print(hauteur(arbre))  # Affiche : 3
</code></pre>

    <div class="important">
        <h3>‚ö†Ô∏è Attention : Conventions</h3>
        <p>Deux conventions coexistent pour la hauteur d'un arbre vide :</p>
        <ul>
            <li><strong>Hauteur = -1</strong> : l'arbre r√©duit √† une feuille a hauteur 0</li>
            <li><strong>Hauteur = 0</strong> : l'arbre r√©duit √† une feuille a hauteur 1</li>
        </ul>
        <p>Dans ce cours, nous adoptons la premi√®re convention (hauteur = -1 pour un arbre vide).</p>
    </div>

    <h2>III. Parcours d'arbres binaires</h2>

    <p>Il existe plusieurs fa√ßons de parcourir un arbre binaire, c'est-√†-dire de visiter tous ses n≈ìuds dans un ordre pr√©cis.</p>

    <h3>3.1 Parcours en profondeur</h3>

    <h4>Parcours pr√©fixe (ou pr√©ordre)</h4>
    <p>On visite d'abord la racine, puis le sous-arbre gauche, puis le sous-arbre droit.</p>
    <pre><code class="python">def parcours_prefixe(arbre):
    """Parcours pr√©fixe : Racine - Gauche - Droit"""
    if arbre is not None:
        print(arbre.valeur, end=' ')
        parcours_prefixe(arbre.gauche)
        parcours_prefixe(arbre.droit)

# R√©sultat : 15 10 5 3 12 20 18 25
</code></pre>

    <h4>Parcours infixe (ou en ordre)</h4>
    <p>On visite le sous-arbre gauche, puis la racine, puis le sous-arbre droit.</p>
    <pre><code class="python">def parcours_infixe(arbre):
    """Parcours infixe : Gauche - Racine - Droit"""
    if arbre is not None:
        parcours_infixe(arbre.gauche)
        print(arbre.valeur, end=' ')
        parcours_infixe(arbre.droit)

# R√©sultat : 3 5 10 12 15 18 20 25
</code></pre>

    <h4>Parcours suffixe (ou postordre)</h4>
    <p>On visite le sous-arbre gauche, puis le sous-arbre droit, puis la racine.</p>
    <pre><code class="python">def parcours_suffixe(arbre):
    """Parcours suffixe : Gauche - Droit - Racine"""
    if arbre is not None:
        parcours_suffixe(arbre.gauche)
        parcours_suffixe(arbre.droit)
        print(arbre.valeur, end=' ')

# R√©sultat : 3 5 12 10 18 25 20 15
</code></pre>

    <h3>3.2 Parcours en largeur</h3>
    <p>On visite les n≈ìuds niveau par niveau, de gauche √† droite. Ce parcours n√©cessite l'utilisation d'une file.</p>
    <pre><code class="python">from collections import deque

def parcours_largeur(arbre):
    """Parcours en largeur (BFS)"""
    if arbre is None:
        return
    
    file = deque([arbre])
    while file:
        noeud = file.popleft()
        print(noeud.valeur, end=' ')
        
        if noeud.gauche is not None:
            file.append(noeud.gauche)
        if noeud.droit is not None:
            file.append(noeud.droit)

# R√©sultat : 15 10 20 5 12 18 25 3
</code></pre>

    <h2>IV. Arbres binaires de recherche (ABR)</h2>

    <div class="definition">
        <h3>üìñ D√©finition : Arbre binaire de recherche</h3>
        <p>Un <strong>arbre binaire de recherche (ABR)</strong> est un arbre binaire qui v√©rifie la propri√©t√© suivante :</p>
        <ul>
            <li>Pour tout n≈ìud, les valeurs du sous-arbre gauche sont <strong>strictement inf√©rieures</strong> √† la valeur du n≈ìud</li>
            <li>Pour tout n≈ìud, les valeurs du sous-arbre droit sont <strong>sup√©rieures ou √©gales</strong> √† la valeur du n≈ìud</li>
        </ul>
    </div>

    <div class="exemple">
        <h3>üí° Propri√©t√© importante</h3>
        <p>Le <strong>parcours infixe</strong> d'un ABR donne les valeurs <strong>tri√©es dans l'ordre croissant</strong>.</p>
        <p>Dans notre exemple : 3, 5, 10, 12, 15, 18, 20, 25 ‚úì</p>
    </div>

    <h3>4.1 Recherche dans un ABR</h3>
    <pre><code class="python">def recherche(arbre, valeur):
    """Recherche une valeur dans un ABR"""
    if arbre is None:
        return False
    if arbre.valeur == valeur:
        return True
    elif valeur < arbre.valeur:
        return recherche(arbre.gauche, valeur)
    else:
        return recherche(arbre.droit, valeur)

# Complexit√© : O(h) o√π h est la hauteur
# Meilleur cas : O(log n) (arbre √©quilibr√©)
# Pire cas : O(n) (arbre d√©g√©n√©r√© en liste)
</code></pre>

    <h3>4.2 Insertion dans un ABR</h3>
    <pre><code class="python">def inserer(arbre, valeur):
    """Ins√®re une valeur dans un ABR"""
    if arbre is None:
        return Noeud(valeur)
    
    if valeur < arbre.valeur:
        arbre.gauche = inserer(arbre.gauche, valeur)
    else:
        arbre.droit = inserer(arbre.droit, valeur)
    
    return arbre

# Exemple d'utilisation
arbre = None
for val in [15, 10, 20, 5, 12, 18, 25, 3]:
    arbre = inserer(arbre, val)
</code></pre>

    <h3>4.3 Complexit√© des op√©rations</h3>
    <table>
        <tr>
            <th>Op√©ration</th>
            <th>Arbre √©quilibr√©</th>
            <th>Arbre d√©g√©n√©r√©</th>
        </tr>
        <tr>
            <td>Recherche</td>
            <td>O(log n)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>Insertion</td>
            <td>O(log n)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>Suppression</td>
            <td>O(log n)</td>
            <td>O(n)</td>
        </tr>
    </table>

    <h2>V. Exercices</h2>

    <div class="exercice">
        <h4>Exercice 1 : Compter les feuilles</h4>
        <p>√âcrire une fonction <code>nombre_feuilles(arbre)</code> qui retourne le nombre de feuilles dans un arbre binaire.</p>
    </div>

    <div class="exercice">
        <h4>Exercice 2 : Valeur maximale</h4>
        <p>√âcrire une fonction <code>valeur_max(arbre)</code> qui retourne la valeur maximale dans un ABR.</p>
    </div>

    <div class="exercice">
        <h4>Exercice 3 : V√©rifier si un arbre est un ABR</h4>
        <p>√âcrire une fonction <code>est_abr(arbre)</code> qui v√©rifie si un arbre binaire est un ABR.</p>
    </div>

    <div class="exercice">
        <h4>Exercice 4 : Somme des valeurs</h4>
        <p>√âcrire une fonction <code>somme(arbre)</code> qui calcule la somme de toutes les valeurs d'un arbre binaire.</p>
    </div>

    <div class="exercice">
        <h4>Exercice 5 : Arbre miroir</h4>
        <p>√âcrire une fonction <code>miroir(arbre)</code> qui retourne un nouvel arbre qui est le miroir de l'arbre donn√© (fils gauche et droit invers√©s).</p>
    </div>

    <div class="liens-utiles">
        <h3>üîó Liens utiles pour s'exercer</h3>
        <a href="https://www.france-ioi.org/" target="_blank">üìù France IOI - Exercices sur les structures de donn√©es</a>
        <a href="https://pixees.fr/informatiquelycee/n_site/nsi_term.html" target="_blank">üìö Pixees - Ressources NSI Terminale</a>
        <a href="https://visualgo.net/en/bst" target="_blank">üé® VisuAlgo - Visualisation des ABR (animation interactive)</a>
        <a href="https://www.cs.usfca.edu/~galles/visualization/BST.html" target="_blank">üéØ USFCA - Visualisation des arbres binaires de recherche</a>
        <a href="https://informatiquelycee.fr/" target="_blank">üìñ Informatique au Lyc√©e - Cours et exercices NSI</a>
        <a href="https://leetcode.com/tag/tree/" target="_blank">üíª LeetCode - Probl√®mes sur les arbres (niveau avanc√©)</a>
    </div>

    <h2>VI. Mini TP Python : Manipulation d'arbres binaires</h2>

    <div class="important">
        <h3>üéØ Objectif du TP</h3>
        <p>Impl√©menter et manipuler des arbres binaires de recherche en Python, en cr√©ant une classe compl√®te avec toutes les op√©rations de base.</p>
    </div>

    <h3>√ânonc√© du TP</h3>
    <p>Vous allez cr√©er un fichier Python contenant une impl√©mentation compl√®te d'un arbre binaire de recherche.</p>

    <h4>Partie 1 : Classe de base</h4>
    <ol>
        <li>Cr√©er une classe <code>Noeud</code> avec les attributs <code>valeur</code>, <code>gauche</code>, et <code>droit</code></li>
        <li>Ajouter une m√©thode <code>__str__</code> pour afficher le n≈ìud</li>
    </ol>

    <h4>Partie 2 : Classe ABR</h4>
    <ol>
        <li>Cr√©er une classe <code>ABR</code> qui encapsule l'arbre</li>
        <li>Impl√©menter les m√©thodes suivantes :
            <ul>
                <li><code>inserer(valeur)</code> : ins√®re une valeur</li>
                <li><code>rechercher(valeur)</code> : recherche une valeur</li>
                <li><code>taille()</code> : retourne le nombre de n≈ìuds</li>
                <li><code>hauteur()</code> : retourne la hauteur</li>
                <li><code>afficher_infixe()</code> : affiche en parcours infixe</li>
                <li><code>afficher_prefixe()</code> : affiche en parcours pr√©fixe</li>
                <li><code>afficher_largeur()</code> : affiche en parcours en largeur</li>
            </ul>
        </li>
    </ol>

    <h4>Partie 3 : Tests</h4>
    <ol>
        <li>Cr√©er un ABR avec les valeurs : [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65]</li>
        <li>Afficher l'arbre avec les diff√©rents parcours</li>
        <li>Tester la recherche de valeurs pr√©sentes et absentes</li>
        <li>Afficher la taille et la hauteur de l'arbre</li>
    </ol>

    <h4>Partie 4 : Fonctions avanc√©es (bonus)</h4>
    <ol>
        <li><code>valeur_min()</code> : retourne la valeur minimale</li>
        <li><code>valeur_max()</code> : retourne la valeur maximale</li>
        <li><code>est_equilibre()</code> : v√©rifie si l'arbre est √©quilibr√©</li>
        <li><code>nombre_feuilles()</code> : compte les feuilles</li>
        <li><code>affichage_graphique()</code> : affiche l'arbre de mani√®re visuelle</li>
    </ol>

    <div class="exemple">
        <h3>üí° R√©sultat attendu</h3>
        <pre><code>Arbre cr√©√© avec succ√®s !

Parcours infixe : 10 20 25 30 35 40 50 60 65 70 80
Parcours pr√©fixe : 50 30 20 10 25 40 35 70 60 65 80
Parcours largeur : 50 30 70 20 40 60 80 10 25 35 65

Taille de l'arbre : 11
Hauteur de l'arbre : 3

Recherche de 35 : Trouv√© ‚úì
Recherche de 100 : Non trouv√© ‚úó

Valeur minimale : 10
Valeur maximale : 80
Nombre de feuilles : 4
</code></pre>
    </div>

    <h3>Code de d√©part du TP</h3>
    <p>Voir le fichier <code>tp_arbres_binaires.py</code> fourni s√©par√©ment.</p>

    <h2>VII. Pour aller plus loin</h2>

    <h3>7.1 Arbres √©quilibr√©s</h3>
    <p>Pour garantir des op√©rations en O(log n), on utilise des arbres auto-√©quilibr√©s :</p>
    <ul>
        <li><strong>Arbres AVL</strong> : diff√©rence de hauteur entre sous-arbres ‚â§ 1</li>
        <li><strong>Arbres Rouge-Noir</strong> : utilis√©s dans les impl√©mentations de dictionnaires</li>
        <li><strong>Arbres B</strong> : utilis√©s dans les bases de donn√©es</li>
    </ul>

    <h3>7.2 Applications pratiques</h3>
    <ul>
        <li><strong>Compression de donn√©es</strong> : arbres de Huffman</li>
        <li><strong>Bases de donn√©es</strong> : index B-tree</li>
        <li><strong>Jeux vid√©o</strong> : arbres de d√©cision pour l'IA</li>
        <li><strong>Compilation</strong> : arbres syntaxiques abstraits (AST)</li>
    </ul>

    <h2>VIII. R√©sum√© du chapitre</h2>

    <div class="objectifs">
        <h3>‚úÖ Points cl√©s √† retenir</h3>
        <ul>
            <li>Un arbre binaire : chaque n≈ìud a au plus 2 enfants</li>
            <li>Hauteur d'un arbre vide : -1 (convention)</li>
            <li>Trois parcours en profondeur : pr√©fixe, infixe, suffixe</li>
            <li>Un parcours en largeur : niveau par niveau (utilise une file)</li>
            <li>ABR : sous-arbre gauche < racine ‚â§ sous-arbre droit</li>
            <li>Parcours infixe d'un ABR ‚Üí ordre croissant</li>
            <li>Complexit√© des op√©rations : O(h) o√π h = hauteur</li>
            <li>Arbre √©quilibr√© ‚Üí O(log n), arbre d√©g√©n√©r√© ‚Üí O(n)</li>
        </ul>
    </div>

    <footer style="margin-top: 50px; padding-top: 20px; border-top: 2px solid #3498db; text-align: center; color: #7f8c8d;">
        <p>Cours NSI Terminale - Les Arbres Binaires</p>
        <p>Conforme au Bulletin Officiel de l'√âducation Nationale</p>
        <p style="font-size: 0.9em;">Pour toute question ou suggestion, n'h√©sitez pas √† consulter votre enseignant(e).</p>
    </footer>
</body>
</html>
</code>
